## Denning-Sacco Modification
We've previously assumed that all keys were secret.
Suppose Eve can obtain session key $k_s$, how does that affect protocol?

### Needham-Schroeder with Denning Sacco Modification
(includes timestamp)
1. $A\implies C : A||B|r_1$ ; Alice sends to Cathy, herself, who she wants to talk to and a nonce
2. $C\implies A: \{A||B||K_{ab}||r_1||\{K_{ab}||A || T\}K_{bc}\}K_{ac}$ ; Including T (timestamp)
	Cathy responds with Alice, Bob, their shared key, the nonce and (Alice and shared key encrypted with Bob's key) all encrypted with Alice's key
3. $A\implies B: \{K_{ab}||A || T\}K_{bc}$
1. $B\implies A: \{r_2\}k_{ab}$
2. $A\implies B : \{r_2-1\}k_{ab}$

### Encrypted Key Exchange - EKE
- Defeats off-line dictionary attacks on challenges
- The idea is that random challenges are enciphered, so attacker cannot verify correct decipherment of a challenge.
- Uses a mix of public and symmetric key cryptography

1. Alice uses shared password $s$ to encrypt randomly selected public key P for a public key system.
	1. Alice forwards $\{p||A\}_s$ to Bob
2. Bob decrypts the public key. Then he generates secret key $k$, and sends $\{k\}_P$ to Alice
Now they share secret key $k$

Alice then can generate a random challenge $R_A$, encrypt it with session key, $k$, send it to Bob, who will reply with $E_k(R_A || R_B)$ and Alice will respond with $E_k(R_B)$

This can be done with *Diffie Hellman*


### Otway-Rees Protocol
- Fixes the issue of Eve replaying third message in Needham-Schroeder
- DOESN'T use timestamps
- Uses an integer $n$ as a kind of "sequence number" to associate all messages with a particular exchange. 


Notice that authentication $\neq$ symmetric key exchange
### Bellare-Rogaway (B-R) Protocol
- Focuses only on symmetric key exchange
- Trusted server (Cathy) sends data to Alice and Bob
- Uses keyed hash functions using Alice's and Bob's secret keys

1. $A \implies B: A||B||r_1$
2. $B \implies C: A||B||r_1||r_2$
3. $C \implies B: \{k_s\}k_b||h_b(A||B||r_2||\{k_s\}k_b)$ ; in which $h_b$ is a keyed hash function
4. $C \implies A: \{k_s\}k_a||h_a(A||B||r_2||\{k_s\}k_a)$ 

When Bob and Alice receive the message, they each compute the hash themselves, and compare.

# Kerberos
\*A three-headed dog in Greek mythology
Is a trusted third party authentication system designed for TCP/IP networks
Industry standard for a while, modern equivalents are based on this

2 Security servers:
1. Central Authentication (CA) server
2. Ticket-Granting server

- Based on Needham-Schroeder with Denning-Sacco modification
- Central authentication and ticket granting server
- Uses DES
A **ticket** is a piece of encrypted data that serves as a secure proof of authentication. (Zero-knowledge proof)

Requirements:
- Eavesdropper cannot obtain enough info to impersonate the user
- User must prove identity for each service invoked
- Servers must prove their identity also!
	- However, we do want to minimize number of times the user has to enter the password
- Authentication server knows passwords,
	- It will send a user's workstation a ticket-granting ticket encrypted by key $k_u$
		- $k_u$ is derived from an encryption of the user's password

User will be using tickets to get session keys.


### Tickets

$T_{u_,tgs}$ for ticket granting server
$T_{u,s}$ ticket for service

- First two steps get user ticket to use TGS
- Next four steps show how *user* gets and uses ticket for service *s*
	- Step 6 is optional, it just shows if the server is alive

#### Problems:
- Relies on synchronized clocks
	- (Replay is possible if not synchronized or old tickets are used and authenticators are not cached)
	- In Kerberos 5, authenticators are valid for 5 minutes, so tickets and authenticators can be replayed within that time.
- Tickets have some fixed fields
	- Dictionary attacks are possible
- Authentication forwarding not possible

"This protocol is secure in the same way that physical ticket protocols are secure"

- Note that the long-term secrets of Alice and Bob are NEVER sent through the network


## Next Slideshow; Key Generation and Certificates
Main ideas:
- Key storing
- Key revocation

#### Randomness
Best sources of randomness are physical phenomenon
- Electromagnetic phenomena
- Disk latency
- Ambient background noise

**Pseudorandom**: intended to simulate a sequence of cryptographically random numbers but generated by an algorithm.
Difficult to do well
Linear congruential and polynomial congruential generators are *broken* (next number in sequence can be determined)

Best Pseudorandom Numbers:
- **Strong mixing function** (AES, SHA-512, SHA-3) used on random unrelated things (specific time and current system processes)
- **Biometrics** represented as bytes


**Cryptographic Key Infrastructure - Storing Keys**
the goal is to *bind identity to a key*
We want to bind identity a public key


- You don't *really* log into different systems with a single password , instead the service contacts another service that knows you and you log in there.
But how do systems know who is who?

We need more than just a digital signature (proof that the key was used)
We need a trusted third party
- Someone trusted by everyone involved in a protocol to help complete the protocol fairly and securely